/*  
 * 문제 요약
 *     - 자연수 n개로 합이 s가 되면서, 각 원소의 곱이 최대가 되는 집합을 구함
 *     - 존재하지 않으면 [-1] 반환
 *
 * 입력  
 *     - int n : 집합의 원소 개수 (1 이상 10,000 이하)
 *     - int s : 집합 원소의 총합 (1 이상 100,000,000 이하)
 *
 * 출력  
 *     - int[] : 조건을 만족하는 집합 (오름차순), 없으면 [-1]
 *
 * 핵심 포인트  
 *     - 곱을 최대로 하려면 값들을 균등하게 분배해야 함
 *     - s를 n으로 나눈 몫을 기본값으로 하고, 나머지만 뒤에서부터 +1로 분배
 *     - 오름차순 정렬은 자동으로 유지됨 (뒤에서부터 증가시키므로)
 */

class Solution {
	
	public int[] solution(int n, int s) {
		if (s < n) return new int[] {-1};  // 합이 n보다 작으면 자연수 조건을 만족할 수 없음

		int[] answer = new int[n];
		
		// 모든 원소에 기본값 할당 (최대한 균등하게 분배)
		for (int i = 0; i < n; i++) {
			answer[i] = s / n;
		}
		
		// 나머지를 뒤에서부터 하나씩 +1
		for (int i = 0; i < s % n; i++) {
			answer[n - 1 - i]++;
		}
		
		return answer;
	}
	
}
